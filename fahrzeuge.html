<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Fahrzeugzählung</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; background: #f7f7f7; margin: 40px; }
        h2 { margin-top: 40px; }
        #container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 8px #ccc; }
        h1 { margin-bottom: 30px; }
        .chart-block { margin-bottom: 50px; }
        canvas { height: 400px !important; width: 100% !important; }
        .input-group { margin-top: 15px; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .input-group label { white-space: nowrap; }
        .input-group input[type="datetime-local"] { padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        .input-group button { padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .input-group button:hover { background-color: #0056b3; }
        #gesamtanzahl { margin: 0 0 20px 0; font-weight: bold; font-size: 1.2em; }
    </style>
</head>
<body>
<div id="container">
    <h1>Fahrzeugzählung</h1>
    
    <div class="chart-block">
        <h2 id="balken-chart-title">Fahrzeugaufkommen nach Typ (Gesamtdaten)</h2>
        <div id="gesamtanzahl"></div>
        <canvas id="fahrzeug-balken"></canvas>
    </div>

    <div class="chart-block">
        <h2>Fahrzeugdichte im Zeitverlauf (Filterbar)</h2>
        Zeitraum-Voreinstellung: 
        <select id="zeitraum-preset">
            <option value="last10min">Letzte 10 Minuten</option>
            <option value="last30min">Letzte 30 Minuten</option>
            <option value="last60min">Letzte 60 Minuten</option>
            <option value="last12h">Letzte 12 Stunden</option>
            <option value="last24h">Letzte 24 Stunden</option>
            <option value="all" selected>Gesamter Verlauf</option> </select>
        <button onclick="applyFilters()">Anzeigen</button>
        <div class="input-group">
            <label for="von-datum-zeit">Von:</label>
            <input type="datetime-local" id="von-datum-zeit">
            <label for="bis-datum-zeit">Bis:</label>
            <input type="datetime-local" id="bis-datum-zeit">
            <button onclick="applyFilters()">Filter anwenden</button> 
        </div>
        <canvas id="fahrzeug-linie"></canvas>
    </div>
</div>

<script>
// Plugin für farbige Hintergrundbereiche im Linien-Chart
const backgroundRangesPlugin = {
    id: 'backgroundRanges',
    beforeDatasetsDraw: (chart) => {
        if (chart.canvas.id !== 'fahrzeug-linie') return;
        const { ctx, chartArea, scales } = chart;
        if (!chartArea || !scales.y) return;
        const ranges = [
            [0, 5, 'green', 0.12],
            [5, 10, 'yellow', 0.13],
            [10, 20, 'orange', 0.13],
            [20, 100, 'red', 0.11]
        ];
        ranges.forEach(([yMin, yMax, color, alpha]) => {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            const y0 = scales.y.getPixelForValue(yMax);
            const y1 = scales.y.getPixelForValue(yMin);
            ctx.fillRect(chartArea.left, y0, chartArea.right - chartArea.left, y1 - y0);
            ctx.restore();
        });
    }
};

const farben = {
    'Auto': 'steelblue',
    'Bus': 'orange',
    'LKW': 'green',
    'Motorrad': 'purple',
    'Kleintransporter': 'red'
};

let alleEintraege = [];

async function fetchFahrzeugDaten() {
    const response = await fetch('Daten/vehicle_counts.txt');
    const text = await response.text();
    const lines = text.trim().split('\n');
    let data = [];
    lines.forEach(line => {
        const match = line.match(/^(\d{4}-\d{2}-\d{2}),\s*(\d{2}:\d{2}:\d{2}),\s*(\w+)$/);
        if (match) {
            const datum = match[1];
            const zeit = match[2];
            const typ = match[3];
            const datetime = new Date(`${datum}T${zeit}`);
            data.push({ datetime, typ });
        }
    });
    data.sort((a, b) => a.datetime - b.datetime);
    return data;
}

function gruppiereNachTyp(data) {
    const counts = {};
    data.forEach(e => {
        counts[e.typ] = (counts[e.typ] || 0) + 1;
    });
    return counts;
}

function gruppiereZeitverlauf(data, intervalMinuten = 1) {
    let result = {};
    if (data.length === 0) return result;
    const allTypes = Object.keys(farben);
    const start = new Date(data[0].datetime);
    const end = new Date(data[data.length - 1].datetime);

    for (let t = new Date(start); t <= end; t.setMinutes(t.getMinutes() + intervalMinuten)) {
        let currentIntervalStart = new Date(t);
        currentIntervalStart.setSeconds(0, 0);
        if (intervalMinuten > 1) {
            currentIntervalStart.setMinutes(Math.floor(currentIntervalStart.getMinutes() / intervalMinuten) * intervalMinuten);
        }
        const labelKey = currentIntervalStart.toISOString();
        if (!result[labelKey]) {
            result[labelKey] = {};
            for (const typ of allTypes) {
                result[labelKey][typ] = 0;
            }
        }
    }

    data.forEach(e => {
        let t = new Date(e.datetime);
        t.setSeconds(0, 0);
        if (intervalMinuten > 1) {
            t.setMinutes(Math.floor(t.getMinutes() / intervalMinuten) * intervalMinuten);
        }
        const labelKey = t.toISOString();
        if (!result[labelKey]) {
            result[labelKey] = {};
            for (const typ of allTypes) {
                result[labelKey][typ] = 0;
            }
        }
        result[labelKey][e.typ] = (result[labelKey][e.typ] || 0) + 1;
    });

    const sortedKeys = Object.keys(result).sort();
    const finalResult = {};
    const hasMultipleDays = sortedKeys.length > 0 && new Date(sortedKeys[0]).getDate() !== new Date(sortedKeys[sortedKeys.length - 1]).getDate();

    sortedKeys.forEach(key => {
        const dateObj = new Date(key);
        let displayLabel;
        if (sortedKeys.length > 60 || hasMultipleDays) {
            displayLabel = dateObj.toLocaleDateString('de-DE', {day:'2-digit', month:'2-digit'}) + ' ' + dateObj.toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit'});
        } else {
            displayLabel = dateObj.toLocaleTimeString('de-DE', {hour:'2-digit', minute:'2-digit', second:'2-digit'});
        }
        finalResult[displayLabel] = result[key];
    });

    return finalResult;
}

let balkenChart, linienChart;

// Beim Laden initialisieren (immer Balkendiagramm für Gesamtdaten, Liniendiagramm filterbar)
async function ladeFahrzeugDaten() {
    alleEintraege = await fetchFahrzeugDaten();
    renderGesamtBalkenChart(); // Balkendiagramm IMMER für alle Daten
    applyFilters(); // Zeitdiagramm ist filterbar
}

// Filterfunktion: beeinflusst NUR das Zeitdiagramm
function applyFilters() {
    const zeitraumPreset = document.getElementById('zeitraum-preset').value;
    const vonStr = document.getElementById('von-datum-zeit').value;
    const bisStr = document.getElementById('bis-datum-zeit').value;

    let filteredEntries = [];
    let chartTitleLine = 'Fahrzeugdichte im Zeitverlauf';
    let intervalMinutes = 1;

    if (vonStr || bisStr) {
        let vonDate = vonStr ? new Date(vonStr) : null;
        let bisDate = bisStr ? new Date(bisStr) : null;

        if (!vonDate && !bisDate) {
            alert('Bitte geben Sie einen "Von"- oder "Bis"-Zeitpunkt für die Filterung an.');
            return;
        }

        filteredEntries = alleEintraege.filter(e => {
            const currentEntryDate = e.datetime;
            const isAfterVon = vonDate ? currentEntryDate >= vonDate : true;
            const isBeforeBis = bisDate ? currentEntryDate <= bisDate : true;
            return isAfterVon && isBeforeBis;
        });

        if (filteredEntries.length === 0) {
            alert('Keine Daten im ausgewählten "Von-bis"-Zeitraum gefunden.');
            renderLineChart([], [], 'Fahrzeugdichte (Keine Daten)');
            return;
        }

        chartTitleLine = `Fahrzeugdichte (Von: ${vonStr || 'Anfang'} Bis: ${bisStr || 'Ende'})`;
        const diffMs = (bisDate || new Date()).getTime() - (vonDate || filteredEntries[0].datetime).getTime();
        const diffHours = diffMs / (1000 * 60 * 60);
        if (diffHours > 24) intervalMinutes = 60;
        else if (diffHours > 4) intervalMinutes = 10;
        document.getElementById('zeitraum-preset').value = 'all';

    } else {
        document.getElementById('von-datum-zeit').value = '';
        document.getElementById('bis-datum-zeit').value = '';

        if (zeitraumPreset === 'all') {
            filteredEntries = alleEintraege;
            chartTitleLine += ' (Gesamter Verlauf)';
            intervalMinutes = 60;
        } else if (zeitraumPreset.startsWith('last')) {
            const now = new Date();
            let cutoffTime;
            if (zeitraumPreset.endsWith('min')) {
                const minutes = parseInt(zeitraumPreset.replace('last', '').replace('min', ''));
                cutoffTime = new Date(now.getTime() - minutes * 60 * 1000);
                chartTitleLine += ` (Letzte ${minutes} Minuten)`;
                intervalMinutes = 1;
            } else if (zeitraumPreset.endsWith('h')) {
                const hours = parseInt(zeitraumPreset.replace('last', '').replace('h', ''));
                cutoffTime = new Date(now.getTime() - hours * 60 * 60 * 1000);
                chartTitleLine += ` (Letzte ${hours} Stunden)`;
                intervalMinutes = 5;
            }
            filteredEntries = alleEintraege.filter(e => e.datetime >= cutoffTime);
            if (filteredEntries.length === 0 && alleEintraege.length > 0) {
                alert('Keine Daten für den ausgewählten Zeitraum gefunden. Möglicherweise ist der Datenbestand älter als der gewählte Zeitraum.');
                renderLineChart([], [], 'Fahrzeugdichte (Keine Daten)');
                return;
            }
        }
    }

    // Daten für Liniendiagramm rendern (nur Zeitfilter wirkt)
    const verlauf = gruppiereZeitverlauf(filteredEntries, intervalMinutes);
    const lineLabels = Object.keys(verlauf);
    const lineDatasets = Object.keys(farben).map(typ => ({
        label: typ,
        data: lineLabels.map(l => verlauf[l][typ] || 0),
        borderColor: farben[typ],
        backgroundColor: farben[typ],
        fill: false,
        tension: 0.1,
        pointRadius: 2
    }));
    renderLineChart(lineLabels, lineDatasets, chartTitleLine);
}

// Balkendiagramm zeigt immer Gesamtdaten!
function renderGesamtBalkenChart() {
    const counts = gruppiereNachTyp(alleEintraege);
    const barLabels = Object.keys(farben).filter(typ => counts[typ] > 0).sort();
    const barData = barLabels.map(typ => counts[typ] || 0);
    const gesamt = barData.reduce((a, b) => a + b, 0);

    document.getElementById('balken-chart-title').innerText = 'Fahrzeugaufkommen nach Typ (Gesamtdaten)';
    document.getElementById('gesamtanzahl').innerText = `Gesamtanzahl Fahrzeuge: ${gesamt}`;

    if (balkenChart) balkenChart.destroy();

    balkenChart = new Chart(document.getElementById('fahrzeug-balken').getContext('2d'), {
        type: 'bar',
        data: {
            labels: barLabels,
            datasets: [{
                label: 'Anzahl',
                data: barData,
                backgroundColor: barLabels.map(typ => farben[typ] || 'gray')
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: false },
                tooltip: { enabled: true }
            },
            scales: {
                y: { 
                    beginAtZero: true, 
                    title: { display: true, text: 'Anzahl der Fahrzeuge' } 
                },
                x: { 
                    title: { display: true, text: 'Fahrzeugtyp' } 
                }
            }
        }
    });
}

function renderLineChart(labels, datasets, titleText) {
    if (linienChart) linienChart.destroy();
    linienChart = new Chart(document.getElementById('fahrzeug-linie').getContext('2d'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { 
                    position: 'right', 
                    align: 'center',
                    labels: { boxWidth: 20 }
                },
                title: {
                    display: true,
                    text: titleText,
                    font: { size: 16 }
                }
            },
            scales: {
                y: { 
                    beginAtZero: true, 
                    max: 200,    // Immer bis 200
                    title: { display: true, text: 'Anzahl Fahrzeuge pro Intervall' } 
                },
                x: {
                    title: { display: true, text: 'Zeit' },
                    ticks: { maxRotation: 45, minRotation: 45 }
                }
            }
        },
        plugins: [backgroundRangesPlugin]
    });
}

// Eventlistener für das Preset-Dropdown
document.getElementById('zeitraum-preset').addEventListener('change', applyFilters);

// Beim Laden initialisieren
ladeFahrzeugDaten();
</script>
</body>
</html>
